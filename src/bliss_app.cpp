#include "build_info.h" //Generated by cmake using buildInfo.h.in template

#include "bliss_app.h"
#include "log_router.h"
#include "perf_timer.h"
#include "entity_manager.h"
#include "entity_memory_pool.h"
#include "entity.h"
#include "components.h"

#include <sstream>

const float Bliss_App::no_spawn_radius = 100.0f;

typedef struct Matrix2d {
	float a, b; // top row
	float c, d; // bottom row
} Matrix2d;

inline Vector2 apply_transformation(Matrix2d t_mat, Vector2 vec) {
	return Vector2 {
		t_mat.a * vec.x + t_mat.b * vec.y,
		t_mat.c * vec.x + t_mat.d * vec.y
	};
}

// 2d rotation matrix
// cos theta, sin theta
// -sin theta, cos theta
inline Matrix2d create_rotation_mat(float rads) {
	// float rads = degrees * DEG2RAD;
	return Matrix2d {
		cosf(rads), sinf(rads),
		-sinf(rads), cosf(rads)
	};
}

inline bool check_circle_overlap(Vector2 a, Vector2 b, float ra, float rb) {
	auto squared_distance = (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
	auto squared_radius = (ra + rb) * (ra + rb);
	return squared_distance < squared_radius;
}

Entity Bliss_App::create_player()
{
	auto& man = Entity_Manager::instance();
	auto e = man.add_entity("player");

	e.add_component<C_Player>();

	auto& initial_pos = e.add_component<C_Position>();
	initial_pos.x = 200;
	initial_pos.y = 200;

	auto& inital_vel = e.add_component<C_Velocity>();
	inital_vel.x = 0;
	inital_vel.y = 0;

	auto& bounding_circle = e.add_component<C_Bounding_Circle>();
	bounding_circle.radius = 100;

	auto& player_tex = e.add_component<C_Texture>();
	player_tex.texture = santa_sm_tex;

	return e;
}

void Bliss_App::create_enemy(int count, Vector2 no_spawn_center, float no_spawn_radius)
{
	static std::string enemy_tag = "enemy";
	auto& man = Entity_Manager::instance();
	for (int i = 0; i < count; i++) {
		float enemy_radius = 50.0f;
		// std::ostringstream s;
		// s << "popper_" << i;
		auto e = man.add_entity(enemy_tag);

		e.add_component<C_Enemy>();

		// random pos within screen size
		auto rnd_vec = Vector2{ 
			(float)GetRandomValue(0, GetScreenWidth()),
			(float)GetRandomValue(0, GetScreenHeight())
		};

		// A is the resulting vector of difference of two positions
		auto A = Vector2 { rnd_vec.x - no_spawn_center.x, rnd_vec.y - no_spawn_center.y };
		auto squared_magintude = A.x * A.x + A.y * A.y;
		auto sum_radius = enemy_radius + no_spawn_radius;
		auto squared_radius = sum_radius * sum_radius;

		// check if the enemy overlaps with the no spawn radius
		if (squared_magintude < squared_radius) { 
			auto magnitude = sqrtf(squared_magintude);
			auto A_normalized = Vector2 { A.x / magnitude, A.y / magnitude };
			rnd_vec = Vector2 { A_normalized.x * sum_radius, A_normalized.y * sum_radius };
		}

		auto& pos = e.add_component<C_Position>();
		pos.x = rnd_vec.x;
		pos.y = rnd_vec.y;

		auto& vel = e.add_component<C_Velocity>();
		vel.x = 0;
		vel.y = 0;

		auto& bounding_circle = e.add_component<C_Bounding_Circle>();
		bounding_circle.radius = 50;

		auto& tex = e.add_component<C_Texture>();
		tex.texture = popper_sm_tex;
	}
}

void Bliss_App::create_bullet(float pos_x, float pos_y, float vel_x, float vel_y, float rot)
{
	static std::string bullet_tag = "bullet";

	auto& man = Entity_Manager::instance();
	auto e = man.add_entity(bullet_tag);

	e.add_component<C_PlayerBullet>();

	auto& pos = e.add_component<C_Position>();
	pos.x = (float)pos_x;
	pos.y = (float)pos_y;

	auto& vel = e.add_component<C_Velocity>();
	vel.x = vel_x;
	vel.y = vel_y;

	auto& bounding_circle = e.add_component<C_Bounding_Circle>();
	bounding_circle.radius = 5;

	auto& tex = e.add_component<C_Texture>();
	tex.texture = snowball_tex;

	auto& r = e.add_component<C_Rotation>();
	r.rotation = rot;
}

Bliss_App::Bliss_App() : dev_ui(Dev_UI::instance())
{
	log_router_enable();
}

void Bliss_App::run()
{
	TraceLog(LOG_INFO, "Starting " BLISS_FULL_HEADER "...\n");
	InitWindow(screen_width, screen_height, BLISS_FULL_HEADER);

	dev_ui.init();

	TraceLog(LOG_INFO, "Loading fonts");
	load_fonts();

	TraceLog(LOG_INFO, "Loading textures");
	load_textures();

	// raylib set fps
	// SetTargetFPS(144);

	TraceLog(LOG_INFO, "Initializing sim");
	Entity_Manager& man = Entity_Manager::instance();
	
	auto p = create_player();
	auto& p_pos = p.get_component<C_Position>();
	create_enemy(5, p_pos, Bliss_App::no_spawn_radius);
	man.update_manager();

	TraceLog(LOG_INFO, "Starting sim loop");
	while (!input_state.exit_window)
	{
		handle_input();
		simulation_step();
		draw_scene();
		draw_game_ui();
		draw_dev_ui();

		render_dev_ui();
		render_scene();

		man.update_manager();

		//Update metrics plot
		dev_ui.plot.UpdateAxes();
	}

	CloseWindow();
}

void Bliss_App::handle_input()
{
	//Input handling
	//----------------------------------------------------------------------------------
	//Note: Input is actually polled inside raylib's EndDrawing (after frame
	//      waiting is finished!) so effectively processing input here (at the 
	//      start of the frame) is as good as processing right after polling
	//      for input.
	Perf_Timer t(dev_ui.metrics.input_time);
	// Entity_Manager& man = Entity_Manager::instance();

	input_state.exit_window = WindowShouldClose();

	input_state.up = IsKeyDown(KEY_W);
	input_state.down = IsKeyDown(KEY_S);
	input_state.left = IsKeyDown(KEY_A);
	input_state.right = IsKeyDown(KEY_D);

	input_state.target_pos = GetMousePosition();
	input_state.fire = IsMouseButtonDown(0);
	input_state.alt_fire = IsMouseButtonPressed(1);

	if (IsKeyPressed(KEY_E)) {
		TraceLog(LOG_INFO, "hi");
	}

	if (!dev_ui.ig_io->WantCaptureMouse)
	{
		//only take mouse input in the game if imgui isn't catching it
		//clicks and input shouldn't go through a window
	}
	if (!dev_ui.ig_io->WantCaptureKeyboard)
	{
		//check keyboard inputs
	}
	if (!dev_ui.ig_io->WantTextInput)
	{
		//for on mobile & consoles
	}
}

bool check_for_overlap(Entity e1, Entity e2)
{
	auto r1 = e1.get_component<C_Bounding_Circle>().radius;
	auto r2 = e2.get_component<C_Bounding_Circle>().radius;

	auto p1 = (Vector2)e1.get_component<C_Position>();
	auto p2 = (Vector2)e2.get_component<C_Position>();

	return check_circle_overlap(p1, p2, r1, r2);
}

void Bliss_App::simulation_step()
{
	//Simulation
	//----------------------------------------------------------------------------------
	Perf_Timer t(dev_ui.metrics.simulation_time);
	// simulate go here

	auto& e_man = Entity_Manager::instance();
	auto& entities = e_man.get_entities();

	// for logic on specific "kinds" of entities
	auto& e_player = e_man.get_entities("player");
	auto& e_enemies = e_man.get_entities("enemy");
	auto& e_bullets = e_man.get_entities("bullet");

	// update player velocity based on input
	for (Entity p : e_player) {
		auto& v = p.get_component<C_Velocity>();

		v.y = 0;
		v.x = 0;

		if (input_state.up) {
			v.y -= 1.0;
		}

		if (input_state.down) {
			v.y += 1.0;
		}

		if (input_state.left) {
			v.x -= 1.0;
		}

		if (input_state.right) {
			v.x += 1.0;
		}

		v.y *= 400;
		v.x *= 400;

		if (input_state.fire || input_state.alt_fire) {
			auto& pos = p.get_component<C_Position>();

			// determine velocity vector
			float distance_x = input_state.target_pos.x - pos.x;
			float distance_y = input_state.target_pos.y - pos.y;

			float squared_magnitude = distance_x * distance_x + distance_y * distance_y;
			float magnitude = sqrtf(squared_magnitude);

			float vector_x = distance_x / magnitude;
			float vector_y = distance_y / magnitude;

			float vel_x = 200 * vector_x;
			float vel_y = 200 * vector_y;

			// determine rotation using the distance vector
			// note our y distance is screen space (unit_y is pointing down)
			// so we need to flip it for standard coordinates
			float rads = atan2(-distance_y, distance_x);

			create_bullet(pos.x, pos.y, vel_x, vel_y, rads);
		}
	}

	// for systems
	//separate loops for separate components, we want to access components
	//across their respective arrays (sequentially in memory), not hopping
	//between different memory regions.

	// update position based on velocity
	for (Entity e : entities)
	{
		if (e.has_component<C_Velocity>() && e.has_component<C_Position>())
		{
			auto& pos = e.get_component<C_Position>();
			auto& vel = e.get_component<C_Velocity>();
			pos.x += vel.x * GetFrameTime();
			pos.y += vel.y * GetFrameTime();
		}
	}

	for (Entity p : e_player) {
		for (Entity e : e_enemies) {
			if (check_for_overlap(p, e)) {
				// player dies
				// TraceLog(LOG_INFO, "Player overlap with enemy");
				e_man.remove_entity(p);
				if (lives > 0) {
					lives--;
					create_player();
				}
				
				int enemy_count = e_enemies.size();

				for (Entity e2 :e_enemies) {
					e_man.remove_entity(e2);
				}

				auto& p_pos = p.get_component<C_Position>();
				create_enemy(enemy_count, p_pos, Bliss_App::no_spawn_radius);
				break;
			}
		}
	}

	for (Entity e : e_enemies) {
		for (Entity b : e_bullets) {
			// enemies and bullets are not removed from the list immediately
			// they are removed on update, however the is_active flag is immediately 
			// updated so we can read that to see if this overlap is real
			if (e.is_active() && b.is_active() && check_for_overlap(e, b)) {
				// enemy dies
				e_man.remove_entity(b);
				e_man.remove_entity(e);

				Vector2 pos {GetScreenWidth() / 2.0f, GetScreenHeight() / 2.0f};
				auto p_entities = e_man.get_entities("player");
				if (p_entities.size() > 0) {
					auto p = p_entities[0];
					auto& p_pos = p.get_component<C_Position>();
					pos = p_pos;
				}
				
				create_enemy(1, pos, Bliss_App::no_spawn_radius);
			}
		}
	}

	for (Entity e : e_bullets) {
		// clean up out of bounds bullets
		auto& pos = e.get_component<C_Position>();
		if (pos.x < -1000 || pos.x > 1000 || pos.y < -1000 || pos.y > 1000) {
			e_man.remove_entity(e);
		}
	}
}

void Bliss_App::draw_scene()
{
	// Draw prep
	//----------------------------------------------------------------------------------
	Perf_Timer t(dev_ui.metrics.draw_prep_time);
	BeginDrawing();

	Entity_Manager& man = Entity_Manager::instance();

	ClearBackground(WHITE);

	//DrawTexture(santa_tex,
	//	screen_width / 2 - santa_tex.width / 2,
	//	screen_height / 2 - santa_tex.height / 2, WHITE);

	// draw
	for (Entity e : man.get_entities())
	{
		bool hasPos = e.has_component<C_Position>();
		if (hasPos && e.has_component<C_Texture>())
		{
			C_Position& pos = e.get_component<C_Position>();
			C_Texture& tex = e.get_component<C_Texture>();
			if (e.has_component<C_Rotation>()) {
				C_Rotation& rot = e.get_component<C_Rotation>();
				//note in case I want to let something rotate or scale (I suspect the above function
				//is faster tho)

				Matrix2d rot_mat = create_rotation_mat(rot.rotation);
				// top left corner relative to the center of the texture
				// to be consistent with the pixel space, the unit vectors
				// point down and right
				Vector2 top_left {
					-(float)tex.texture.width / 2,
					-(float)tex.texture.height / 2
				};
				Vector2 rotated_corner = apply_transformation(rot_mat, top_left);
				
				Vector2 renderPos {
					pos.x + rotated_corner.x,
					pos.y + rotated_corner.y
				};

				//raylib's degrees are inverted for some reason
				DrawTextureEx(tex.texture, renderPos, 360 - rot.rotation * RAD2DEG, 1.0f, WHITE);  
				// DrawRectangle((int)renderPos.x, (int)renderPos.y, 3, 3, BLUE);
				DrawCircle((int)renderPos.x, (int)renderPos.y, 1, BLUE);
			} else {
				DrawTexture(tex.texture, (int)pos.x - tex.texture.width / 2, (int)pos.y - tex.texture.height / 2, WHITE);
				DrawCircle((int)pos.x - tex.texture.width / 2, (int)pos.y - tex.texture.height / 2, 1, BLUE);
				// DrawRectangle((int)pos.x - tex.texture.width / 2, (int)pos.y - tex.texture.height / 2, 3, 3, BLUE);
			}
		}

		// bounding circle debug
		if (hasPos && e.has_component<C_Bounding_Circle>())
		{
			C_Position& pos = e.get_component<C_Position>();
			C_Bounding_Circle& bounds = e.get_component<C_Bounding_Circle>();
			Color translucentRed = RED;
			translucentRed.a = 128;
			DrawCircleLines((int)pos.x, (int)pos.y, bounds.radius, RED);
			DrawCircle((int)pos.x, (int)pos.y, bounds.radius, translucentRed);
		}

		if (hasPos)
		{
			C_Position& pos = e.get_component<C_Position>();
			DrawCircle((int)pos.x, (int)pos.y, 1, GREEN);
			// DrawRectangle((int)pos.x, (int)pos.y, 3, 3, GREEN);
		}
	}

	Vector2 text_dim = MeasureTextEx(font_roboto_mono, BLISS_FULL_HEADER,
		(float)font_roboto_mono.baseSize, 0);
	Vector2 text_pos;
	text_pos.x = ((float)screen_width - text_dim.x) / 2.0f;
	text_pos.y = ((float)screen_height - text_dim.y) / 2.0f;
	
	//text_pos.x = ((float)screen_width  - text_dim.x) / 2.0f;
	//text_pos.y = ((float)screen_height - text_dim.y) / 2.0f;

	DrawTextEx(font_roboto_mono, BLISS_FULL_HEADER, text_pos,
		(float)font_roboto_mono.baseSize, 0, DARKGRAY);
}

void Bliss_App::draw_game_ui()
{
	Perf_Timer t(dev_ui.metrics.game_ui_time);
	std::ostringstream s;
	s << "Lives: " << lives;

	Vector2 text_pos {40, 40};
	DrawRectangle(30, 30, 120, 50, BLACK);
	DrawTextEx(font_roboto_mono, s.str().c_str(), text_pos,
		(float)font_roboto_mono.baseSize, 0, WHITE);
}


void Bliss_App::draw_dev_ui()
{
	static size_t current_entity = 0;
	//----------------------------------------------------------------------------------
	//Dev UI
	Perf_Timer t(dev_ui.metrics.dev_ui_time);

	dev_ui.new_frame();
	dev_ui.draw();

	ImVec2 vec2_zero = { 0.0f, 0.0f };
	ImVec2 vec2_one = { 1.0f, 1.0f };
	ImVec4 vec4_zero = { 0.0f, 0.0f, 0.0f, 0.0f };
	ImVec4 vec4_one = { 1.0f, 1.0f, 1.0f, 1.0f };
	ImVec2 size;
	size.x = (float)santa_tex.width / 4.0f;
	size.y = (float)santa_tex.height / 4.0f;
	if (ImGui::Begin("Entity viewer", nullptr, 0))
	{
		//ImGui::InputInt("current_entity", &current_entity);
		size_t step = 1;
		size_t fast_step = 10;
		ImGui::InputScalar("", ImGuiDataType_U64, &current_entity, &step, &fast_step);

		auto& man = Entity_Manager::instance();
		auto& entities = man.get_entities();
		for (auto e : entities) {
			if (e.get_id() == current_entity) {
				ImGui::Text("Tag: %s", e.get_tag().c_str());
				if (e.has_component<C_Position>())
				{
					auto& pos = e.get_component<C_Position>();
					ImGui::Text("Pos X: %f", pos.x);
					ImGui::Text("Pos Y: %f", pos.y);
				}
				break;
			}
		}
	}
	ImGui::End();

	// ImGui::ShowDemoWindow();

	log_gui.draw("Log");
}

void Bliss_App::render_dev_ui()
{
	Perf_Timer t(dev_ui.metrics.dev_ui_render_time);
	dev_ui.render();
}

void Bliss_App::render_scene()
{
	Perf_Timer t(dev_ui.metrics.drawing_time);
	EndDrawing();
}

void Bliss_App::load_fonts() {
	font_roboto_mono = LoadFontEx("data/fonts/RobotoMono-Regular.ttf", 28, nullptr, 255);
	font_roboto_mono_sm = LoadFontEx("data/fonts/RobotoMono-Regular.ttf", 12, nullptr, 255);
	font = LoadFontEx("data/fonts/Merriweather-Regular.ttf", 14, nullptr, 255);
}

void Bliss_App::load_textures() {
	santa_tex = LoadTexture("data/santa/Idle (1).png");
	santa_sm_tex = LoadTexture("data/santa/Idle (1) - Cropped - Small.png");
	popper_sm_tex = LoadTexture("data/santa/Idle (1) - Cropped - Small - Inverted.png");
	santa_cropped_tex = LoadTexture("data/santa/Idle (1) - Cropped.png");
	snowball_tex = LoadTexture("data/snowball/snowball_01_sm_mirrored.png");
}

Bliss_App::~Bliss_App()
{
	TraceLog(LOG_INFO, "Unloading fonts...");
	UnloadFont(font_roboto_mono);
	UnloadFont(font_roboto_mono_sm);
	UnloadFont(font);

	TraceLog(LOG_INFO, "Unloading textures...");
	UnloadTexture(santa_tex);
	UnloadTexture(santa_sm_tex);
	UnloadTexture(popper_sm_tex);
	UnloadTexture(santa_cropped_tex);
	UnloadTexture(snowball_tex);
}
